// Welcome to the `enum` language!!
//
// Where we use enums for a bunch a shit.

// To consider...
//
//    - Jai's build scripts being built into the `main` file is nice
//    - Macros/some way of compile time meta programing
//    - First class compile time types like Zig


enum Shape {
    pub color: string,

    Circle { rad: int },
    Rectangle { height: int, width: int },
}

// So here is inheritance
int area(Shape x) {
    match x {
        Shape::Circle { rad } -> {
            return (rad * rad) * 3.141;
        }
        Shape::Rectangle { height, width } -> {
            return height * width;
        }
    }
}

// This would be made really nice with variants as types
int circumference(Shape::Circle x) {
    return x.rad * 2 * 3.141;
}

enum Result<T, E> {
    Ok(E), Err(E)
}

Result<int, NotInstanceError?> maybe_call_circumference(Shape x) {
    match x {
        circle @ Shape::Circle { .. } -> {
            // The type of circle is `Shape::Circle`
            return Result::Ok(circumference(circle));
        }
        _ -> {
            return Result::Err(NotInstanceError);
        }
    }
}

// Default struct/enum fields
struct Foo {
    size: int,
    color: string,

    meta: string = "hello",
    // Or           maybe no type?
    meta = "hello": string,
}

// I really like the idea of "compile time" first class types
T passed_in_type<T: ptr_fam>(it: Type) {
    printf("%s", it.name); // use just as any other type

    if (it.is_sized()) {
        // Higher Kinded Types ish?? maybe??
        // Since the check on Type would be different I wonder if this would work easily
        return <<T<it>>::ptr_fam>();
    } else {

    }
}
